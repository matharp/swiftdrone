# swiftdrone.py

https://github.com/GetSwift/codetest

I implemented my solution in Python 2.7.13 as a simple script called swiftdrone.py. The script depends on two 3rd party packages: haversine (https://pypi.python.org/pypi/haversine) and requests (https://github.com/requests/requests). To run the script, please make sure you have the two packages installed and then just run the script in your shell. The script should consume the API, generate a solution and dump a JSON response. Every character was written in Vim :).

Before I started writing any code, I tried to formalize the problem. Essentially, we need to implement a scheduler for a real-time system with soft deadlines. The scheduling algorithm has to be non-preemptive. The problem is analogues to the multi-processor scheduling problem with deadlines. The constraints entail that we need to use the earliest-deadline first algorithm.

The script prioritizes the queues and packages based on two of their attributes: distance to depot and deadlines, respectively. After we generate the two priority queues of packages and drones, we iterate over the package queue and see if the first drone in the drone queue can service our request. If it can, we a dequeue the drone from our drone queue and assign it to the package by putting it in our 'assigned' list. If it can't, we put the package in our 'unassigned' list. This approach is simple to implement and I believe this is the best algorithm given the constraints in the system. The time complexity will be: O(m+n) = mlogm + nlogn where m and n are the number of drones and packages.

If I need to re-write this code for a scalable system, I would make some changes. I would use a min-heap in place of a Python list of objects. This way, we can keep on adding new drones and packages to our queues with reasonable run-time cost: O(logn) where n is the number of the heap objects. By doing this, after we assign a drone to a package, we can always pop drones from our heap in O(1) time and we have the next 'best' drone ready to be popped from the heap again. Also, we would need the system to be a lot more efficient in terms of computing resources. So I believe a solution in something like Rust, Go or something 'more efficient' would be preferable over Python; of course, I need to do some tests to backup the claim. Algorithmically, I don't think we can do better than the earliest-deadline first algorithm given the constraints.
